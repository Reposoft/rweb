<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>head.js testcases</title>
<script type="text/javascript" src="../lib/scriptaculous/prototype.js"></script>
<script type="text/javascript" src="../lib/scriptaculous/unittest.js"></script>
<script type="text/javascript" src="../head.js"></script>
<!-- import after head.js so it is not updated with theme url -->
<link href="../../style/global.css" rel="stylesheet" type="text/css" />
</head>

<body>
<h1>Test head.js, the Repos class.</h1>
<p><a class="action" href="../">return to javascript test page</a></p>
<div id="testlog"></div>

<script type="text/javascript">

var aFunctionCalled = false;
var	anAspectCalled = false;
function ClassOne(){}
ClassOne.prototype = {
	aFunction: function(myarg) {
		aFunctionCalled = myarg;
	}
}
function ClassTwo(){}
ClassTwo.prototype = {
	anAspect: function(myarg) {
		anAspectCalled = myarg;
		// don't return anything, because then the real function is not called
	},
	interruptingAspect: function(myarg) {
		anAspectCalled = myarg;
		return true;
	}
}

// save some of the page state as it is during page load
var _loaded = Repos.isPageLoaded();

// do require as a plugin wouls have done it: right when the script loads
Repos.require('unittest/resources/mytestlib.js');

// a flag that can be used form any testcase
var flag = false;
function flagTrue() {
	flag = true;
}
function dummy() {
}

// Test runner starts once the page has loaded (I think it does that anyway)
function afterLoad() {
new Test.Unit.Runner({

	setup: function() { with(this) {
		aFunctionCalled = false;
		anAspectCalled = false;
		flag = false;
	}},
	
	testBeforeLoad: function() { with(this) {
		assertEqual(false, _loaded, "Until window.onload, Repos.isPageLoaded() should return true");
	}},
	
	testAfterLoad: function() { with(this) {
		assertEqual(true, Repos.isPageLoaded(), "The page should have loaded now, and repos should know it");
	}},
	
	testWindowOnloadSet: function() { with(this) {
		assertEqual('function', typeof(window.onload), 'Body onload should call the second Repos initializer');
	}},

	testAfterLoad: function() { with(this) {
		assertEqual(true, Repos.isPageLoaded(), "Repos should know that page has loaded now");
		if (_repos_loading) {
			info("Note, for the tests running now, that the load queue is still processing");
		}
	}},

	testStaticScriptNotImported: function() { with(this) {
		var n = document.getElementsByTagName('head')[0].childNodes;
		var foundOnce = false;
		var p = /prototype.js/;
		for (i = 0; i < n.length; i++) {
			if (n[i].src && p.test(n[i].src)) {
				if (foundOnce) {
					fail("prototype.js has been imported, but it was already in the static head");
					return;
				}
				foundOnce = true;
			}
		}
		pass();
	}},

	// check that the lib imported in head is present now
	testRequireBeforePageLoaded: function() { with(this) {
		assertEqual(false, typeof(MyTestlib) == 'undefined', "Can not finde MyTestlib that was required before the test");
		var myTest = new MyTestlib('arg');
		assertEqual('arg', myTest.getInitarg(), "MyTestlib should have an instance varable value now");
	}},
	
	// test that the AOP functionality works, becuase it is required for proper body.onload handling
	testBeforeAdvice: function() { with(this) {
		var c1 = new ClassOne();
		var c2 = new ClassTwo();
		Repos.addBefore(c2.anAspect, ClassOne, 'aFunction');
		c1.aFunction('arg');
		assertEqual('arg', aFunctionCalled, 'original method should have been called after the Before advice, because the advice did not return anything');
		assertEqual('arg', anAspectCalled, 'AOP advice should have been called with the same argument');
	}},
	
	testBeforeAdviceInterrupt: function() { with(this) {
		var c1 = new ClassOne();
		var c2 = new ClassTwo();
		Repos.addBefore(c2.interruptingAspect, ClassOne, 'aFunction');
		c1.aFunction('arg');
		assertEqual(false, aFunctionCalled, 'original function should not have been called, because the aspect returned somethind');
		assertEqual('arg', anAspectCalled, 'AOP advice should have been called with the same argument');
	}},
	
	testBeforeReposFunction: function() { with(this) {
		assertEqual(false, flag, 'test logic error: flag should be false before test');
		Repos.addBefore(flagTrue, Repos, 'createElement');
		Repos.createElement("div");
		assertEqual(true, flag, 'before advice should have been called for this repos function');
	}},
	
	testBeforeNonexistingFunction: function() { with(this) {
		try {
			Repos.addBefore(flagTrue, ClassOne, 'methodThatDoseNotExist');
		} catch(err) {
			info("Correctly got the exception: " + err);
			pass();
			return;
		}
		fail('AOP method addBefore should throw exception if the original method does not exist');
	}},
	
	testEventObserveAspect: function() { with(this) {
		assertEqual(true, Repos.isPageLoaded(), "Page should have loaded, or else this test does not prove anything");
		Event.observe(window, 'load', flagTrue, false);
		var toBeLoaded = _repos_loadqueue.pop();
		_repos_loadqueue.push(dummy); // replace with something so that the queue logic is not confused
		assertEqual(flagTrue, toBeLoaded, "The onload method should have been added to the load queue");
	}},
	
	// check that the AOP things don't affect the original Prototype behaviour
	testAddAnyObserver: function() { with(this) {
		assertEqual(false, flag, 'test logic error: flag should be false before test');
		var e = document.getElementsByName('testelement')[0];
		Event.observe(e, 'focus', flagTrue, false);
		e.focus();
		assertEqual(true, flag, 'onfocus observer for the testelement should have been called');
	}},

	testRequire: function() { with(this) {
		Repos.require('lib/scriptaculous/unittest.js');
		var toBeLoaded = _repos_loadqueue.pop();
		_repos_loadqueue.push(dummy); // replace with something so that the queue logic is not confused
		assertEqual('lib/scriptaculous/unittest.js', toBeLoaded, "The script should have been added to the load queue");
	}},
	
	testRequirePlugin: function() { with(this) {
		Repos.requirePlugin('dateformat');
		var toBeLoaded = _repos_loadqueue.pop();
		_repos_loadqueue.push(dummy); // replace with something so that the queue logic is not confused
		assertEqual('plugins/dateformat/dateformat.js',	toBeLoaded, "The script should have been added to the load queue");
	}},
	
	testIsScriptResourceLoaded: function() { with(this) {
		_repos_loadedlibs.push('qwerty');
		assertEqual(true, Repos.isScriptResourceLoaded('qwerty'),
			"Should find the script url in the stack of loaded libs");
		_repos_loadedlibs.pop();
	}},
	
	testLoadScript: function() { with(this) {
		// using addBefore to mock appendChild
		Repos.addBefore(flagTrue, Repos.documentHead, 'appendChild');
		Repos._loadScript('lib/qwerty.js');
		var wasloaded = _repos_loadedlibs.pop();
		assertEqual(true, flag, 'script should have been added to the dom');
		assertEqual('lib/qwerty.js', wasloaded, 'script URL should have been saved in the loadedlibs stack');
	}},
	
	testVerifyResourceUrl: function() { with(this) {
		var yes = Repos.verifyResourceUrl('lib/scriptaculous/unittest.js');
		assertEqual(true, yes, "Should see that resource lib/scriptaculous/unittest.js exists");
	}},
	
	testVerifyResourceUrlFail: function() { with(this) {
		var no = Repos.verifyResourceUrl('lib/resource/that/does/not/exist.js');
		assertEqual(false, no, "Not an existing resource: lib/resource/that/does/not/exist.js");
	}},	
	
	testVerifyResourceUrlParent: function() { with(this) {
		var yes = Repos.verifyResourceUrl('../style/global.css');
		assertEqual(true, yes, "CSS resource in repos dir (../style/global.css) should also be ok.");
	}},
	
	testNamespaceURI: function() { with(this) {
		var ns = Repos.defaultNamespace;
		assertEqual(null, ns, "This page is not loaded as text/xml or application/xhtml+xml, so it should not be treated with namespace.");
	}},
	
	testHandleScriptLoaded: function() { with(this) {
		_repos_pluginLoadCallback.push(flagTrue); // until there is an associative array
		Repos._handleScriptLoaded('plugins/dateformat/dateformat.js');
		assertEqual(true, flag, 'The pluginsLoaded callbacks should have been called');
	}},
	
	testHandleException: function() { with(this) {
		try {
			throw new Error("This is expected. Testing error handling.");
		} catch (err) {
			Repos.handleException(err);
		}
		info('An error log entry should now have been added to /repos/errorlog');
		// TODO assert that script and line number is in it (on firefox)
	}},

	testCookies: function() { with(this) {
		Repos.setCookie('testcookie', 'value');
		var v = Repos.getCookie('testcookie');
		assertEqual('value', v, "set+getCookie should communicate through cookies");
		Repos.setCookie('test2', 'value2');
		v = Repos.getCookie('testcookie');
		assertEqual('value', v, "should be able to handle different cookies");
		Repos.deleteCookie('testcookie');
		v = Repos.getCookie('testcookie');
		assertNull(v, "should be able to clear cookie");
	}},
	
	testResourceId: function() { with(this) {
		var testid = 'version $URL: https://svn.optime.se/optime/repos/trunk/www/index.html $ $Rev: 1602 $';
		var rid = new ReposResourceId(testid);
		assertEqual('dev', rid.getRelease(), "It is trunk so release should be 'dev'");
		assertEqual('1602', rid.getRevision(), "Should return the revision from Rev");
	}}, 
	
	testResourceIdBranch: function() { with(this) {
		var testid = 'version $URL: https://svn.optime.se/optime/repos/branches/www-1.2/index.html $ $Rev: 100 $';
		var rid = new ReposResourceId(testid);
		assertEqual('1.2 dev', rid.getRelease(), "Should find the release version in the URL");
		assertEqual('100', rid.getRevision(), "Should return the revision from Rev");
	}}, 
	
	testResourceIdTag: function() { with(this) {
		var testid = 'version $URL: https://svn.optime.se/optime/repos/tags/www-1.2.1/index.html $ $Rev: 1602 $';
		var rid = new ReposResourceId(testid);
		assertEqual('1.2.1', rid.getRelease(), "URL is a tag so version number should be final");
	}},
	
	testResourceIdOnlyURL: function() { with(this) {
		var testid = '$URL: https://svn.optime.se/optime/repos/branches/www-1.2/index.html $';
		var rid = new ReposResourceId(testid);
		assertEqual('1.2 dev', rid.getRelease(), "URL is a branch so should be version + dev");
		assertEqual('', rid.getRevision(), "There is no Rev");
	}},
	
	testResourceIdOnlyRev: function() { with(this) {
		var testid = '$Rev: 1602 $ only';
		var rid = new ReposResourceId(testid);
		assertEqual('', rid.getRelease(), "No URL so release should be empty");
		assertEqual('1602', rid.getRevision(), "Should return the revision from Rev");
	}},
	
	testResouceIdId: function() { with(this) {
		var testid = 'repos.se stylesheet version $Id: repos.xsl 1601 2006-09-14 09:09:50Z solsson $';
		var rid = new ReposResourceId(testid);
		assertEqual('1601', rid.getRevision(),'"Should be able to get revision number from $Id$ keyword too');
		assertEqual('', rid.getRelease(), 'There is no branch info in $Id$');
	}},
	
	testGetResourceversion: function() { with(this) {
		var testid = 'version $URL: https://svn.optime.se/optime/repos/tags/www-1.2.1/index.html $ $Rev: 1602 $';
		var v = Repos._getResourceVersion(testid);
		assertEqual('1.2.1', v, "Should not give revision number because this is a tag");
	}},
	
	testGetReleaseversion: function() { with(this) {
		var testid = 'version $URL: https://svn.optime.se/optime/repos/branches/trunk/index.html $ $Rev: 1602 $';
		var v = Repos._getReleaseVersion(testid);
		assertEqual('version dev', v, "Should not show revision in 'releaseversion'");
	}},
	
	testGetResourceversion: function() { with(this) {
		var testid = '$URL: https://svn.optime.se/optime/repos/branches/www-1.2/index.html $ $Rev: 1602 $ now'
		var v = Repos._getResourceVersion(testid);
		assertEqual('1.2 dev 1602 now', v, "Should return both release and revision for branch");
	}},
	
	// for copy-paste
	testTemplate: function() { with(this) {
	}},

	teardown: function() { with(this) {}}
}, { });
}

// use prototype to set body.onload
Event.observe(window, 'load', afterLoad, false);

</script>
<form id="testform">
<p><input id="testelement" name="testelement" type="text" value="testelement"/></p>
</form>
</body>
</html>
